<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Ultimate Log Splitter (4GB+ & High Speed)</title>
    <style>
        body { font-family: -apple-system, sans-serif; padding: 40px; background: #f8f9fa; color: #333; }
        .container { max-width: 800px; margin: auto; background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        #drop-zone { border: 3px dashed #dee2e6; padding: 60px; text-align: center; border-radius: 10px; cursor: pointer; background: #fff; transition: all 0.2s; }
        #drop-zone:hover { border-color: #007bff; background: #f1f7ff; }
        .status-box { margin: 20px 0; padding: 15px; border-radius: 8px; background: #e9ecef; font-weight: bold; }
        .progress-bar { height: 20px; background: #eee; border-radius: 10px; overflow: hidden; margin-bottom: 10px; }
        .progress-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #007bff, #00d4ff); transition: width 0.3s; }
        .file-list { max-height: 400px; overflow-y: auto; margin-top: 20px; border-top: 2px solid #eee; }
        .file-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid #eee; font-family: monospace; }
        .download-btn { background: #28a745; color: white; padding: 6px 15px; border-radius: 5px; text-decoration: none; font-size: 0.9em; }
    </style>
</head>
<body>

<div class="container">
    <h2>로그 분할기 3.0 <small>(초대용량 모드)</small></h2>
    <p>4GB 이상의 대용량 파일도 바이트 단위로 분석하여 멈춤 없이 분할합니다.</p>
    
    <div id="drop-zone">이곳에 .log 파일을 드래그하거나 클릭하세요</div>
    <input type="file" id="file-input" style="display:none">

    <div class="status-box" id="status-container">
        <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
        <div id="status-text">대기 중...</div>
    </div>

    <div class="file-list" id="file-list"></div>
</div>

<script>
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');
const progressFill = document.getElementById('progress-fill');
const statusText = document.getElementById('status-text');
const fileList = document.getElementById('file-list');

// 구분자 설정 (UTF-8 바이트)
const DELIMITER = "모든 그룹에 대한 백테스트 완료";
const DELIMITER_BYTES = new TextEncoder().encode(DELIMITER);

dropZone.onclick = () => fileInput.click();
fileInput.onchange = (e) => processLargeFile(e.target.files[0]);

async function processLargeFile(file) {
    if (!file) return;

    // 초기화
    fileList.innerHTML = '';
    statusText.innerText = "분석 시작...";
    
    let startOffset = 0;
    let currentPos = 0;
    let foundCount = 0;
    
    // 1GB당 한 번씩만 끊기지 않도록 CHUNK_SIZE를 32MB로 설정
    const CHUNK_SIZE = 32 * 1024 * 1024; 

    while (currentPos < file.size) {
        // 파일을 쪼개서 읽음
        const endPos = Math.min(currentPos + CHUNK_SIZE, file.size);
        const blob = file.slice(currentPos, endPos + DELIMITER_BYTES.length);
        const arrayBuffer = await blob.arrayBuffer();
        const view = new Uint8Array(arrayBuffer);

        let offsetInChunk = 0;

        while (true) {
            // 바이트 기반 고속 검색
            const idx = findIndex(view, DELIMITER_BYTES, offsetInChunk);
            
            if (idx === -1) break;

            // 찾았을 경우
            const absoluteEnd = currentPos + idx + DELIMITER_BYTES.length;
            addFileItem(file, startOffset, absoluteEnd, ++foundCount);
            
            startOffset = absoluteEnd;
            offsetInChunk = idx + DELIMITER_BYTES.length;
        }

        currentPos += CHUNK_SIZE;
        
        // UI 업데이트 및 브라우저 휴식 (이게 없으면 멈춤)
        const progress = Math.min(100, (currentPos / file.size) * 100).toFixed(1);
        progressFill.style.width = progress + '%';
        statusText.innerText = `분석 중: ${progress}% (발견된 로그: ${foundCount}개)`;
        
        // 브라우저가 다른 일을 할 수 있게 0.001초 쉼
        await new Promise(resolve => setTimeout(resolve, 0));
    }

    // 마지막 조각 처리
    if (startOffset < file.size) {
        addFileItem(file, startOffset, file.size, ++foundCount);
    }

    statusText.innerText = `분석 완료! 총 ${foundCount}개의 파일을 찾았습니다.`;
}

/**
 * Uint8Array에서 특정 바이트 패턴의 인덱스를 찾는 최적화 함수
 */
function findIndex(source, pattern, start) {
    for (let i = start; i <= source.length - pattern.length; i++) {
        if (source[i] === pattern[0]) {
            let match = true;
            for (let j = 1; j < pattern.length; j++) {
                if (source[i + j] !== pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) return i;
        }
    }
    return -1;
}

function addFileItem(originalFile, start, end, index) {
    const size = end - start;
    if (size <= 0) return;

    const sliceBlob = originalFile.slice(start, end);
    const url = URL.createObjectURL(sliceBlob);
    const filename = `backtest_part_${String(index).padStart(3, '0')}.log`;

    const div = document.createElement('div');
    div.className = 'file-item';
    div.innerHTML = `
        <span>${filename} (${formatSize(size)})</span>
        <a href="${url}" download="${filename}" class="download-btn">다운로드</a>
    `;
    fileList.appendChild(div);
}

function formatSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    if (bytes < 1073741824) return (bytes / 1048576).toFixed(1) + ' MB';
    return (bytes / 1073741824).toFixed(1) + ' GB';
}
</script>

</body>
</html>
