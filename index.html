<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>초대용량 로그 분할기 (4GB+ 지원)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background: #f0f2f5; }
        .card { background: white; max-width: 700px; margin: auto; padding: 25px; border-radius: 12px; shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #drop-zone { border: 3px dashed #cbd5e0; padding: 50px; text-align: center; border-radius: 10px; cursor: pointer; background: #fff; transition: 0.2s; }
        #drop-zone:hover { border-color: #4299e1; background: #ebf8ff; }
        .progress-bar { height: 12px; background: #edf2f7; border-radius: 6px; overflow: hidden; margin: 20px 0; display: none; }
        .progress-fill { width: 0%; height: 100%; background: #48bb78; transition: width 0.2s; }
        .info { color: #4a5568; font-size: 0.9em; margin-bottom: 10px; }
        .log-list { max-height: 300px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px; display: none; }
        .item { display: flex; justify-content: space-between; padding: 8px; border-bottom: 1px solid #edf2f7; font-size: 0.85em; }
        .btn-dl { color: #3182ce; text-decoration: none; font-weight: bold; }
    </style>
</head>
<body>

<div class="card">
    <h2>로그 분할기 <small>(대용량 모드)</small></h2>
    <p class="info">파일을 메모리에 올리지 않고 위치 값만 계산하여 즉시 분할합니다. (4GB+ 최적화)</p>

    <div id="drop-zone">이곳에 대용량 로그 파일을 놓으세요</div>
    <input type="file" id="file-input" style="display:none">

    <div class="progress-bar" id="progress-container"><div class="progress-fill" id="progress-fill"></div></div>
    <div id="status" class="info"></div>

    <div class="log-list" id="log-list"></div>
</div>

<script>
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');
const progressContainer = document.getElementById('progress-container');
const progressFill = document.getElementById('progress-fill');
const statusText = document.getElementById('status');
const logList = document.getElementById('log-list');

// 찾을 문구 (UTF-8 바이트 배열로 변환)
const DELIMITER_TEXT = "모든 그룹에 대한 백테스트 완료";
const encoder = new TextEncoder();
const DELIMITER_BYTES = encoder.encode(DELIMITER_TEXT);

dropZone.onclick = () => fileInput.click();
fileInput.onchange = (e) => processFile(e.target.files[0]);

async function processFile(file) {
    if (!file) return;

    // UI 초기화
    logList.innerHTML = '';
    logList.style.display = 'block';
    progressContainer.style.display = 'block';
    
    let startOffset = 0;
    let currentPos = 0;
    let fileCount = 1;
    const CHUNK_SIZE = 16 * 1024 * 1024; // 16MB씩 검색 (안정적)

    while (currentPos < file.size) {
        const slice = file.slice(currentPos, currentPos + CHUNK_SIZE + DELIMITER_BYTES.length);
        const buffer = await slice.arrayBuffer();
        const view = new Uint8Array(buffer);

        for (let i = 0; i < view.length - DELIMITER_BYTES.length; i++) {
            // 바이트 단위로 패턴 매칭 (메모리 부담 0)
            let match = true;
            for (let j = 0; j < DELIMITER_BYTES.length; j++) {
                if (view[i + j] !== DELIMITER_BYTES[j]) {
                    match = false;
                    break;
                }
            }

            if (match) {
                const endOffset = currentPos + i + DELIMITER_BYTES.length;
                addDownloadItem(file, startOffset, endOffset, fileCount++);
                startOffset = endOffset;
                // 매칭된 부분 이후부터 다시 검색
                i += DELIMITER_BYTES.length - 1;
            }
        }

        currentPos += CHUNK_SIZE;
        const pct = Math.min(100, Math.round((currentPos / file.size) * 100));
        progressFill.style.width = pct + '%';
        statusText.innerText = `분석 중... ${pct}% (분할된 파일: ${fileCount - 1}개)`;
    }

    // 마지막 남은 부분 처리
    if (startOffset < file.size) {
        addDownloadItem(file, startOffset, file.size, fileCount++);
    }

    statusText.innerText = `분석 완료! 총 ${fileCount - 1}개 발견.`;
}

function addDownloadItem(originalFile, start, end, index) {
    // 중요: file.slice는 실제 데이터를 복사하지 않고 포인터만 만듭니다 (매우 빠름)
    const blob = originalFile.slice(start, end);
    const url = URL.createObjectURL(blob);
    const name = `part_${String(index).padStart(3, '0')}.log`;

    const div = document.createElement('div');
    div.className = 'item';
    div.innerHTML = `
        <span>${name} (${formatBytes(blob.size)})</span>
        <a href="${url}" download="${name}" class="btn-dl">다운로드</a>
    `;
    logList.appendChild(div);
}

function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
</script>
</body>
</html>
